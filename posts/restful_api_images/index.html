<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Restful API设计最佳实践? | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content="restful"><meta name=description content="REST API？

REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。
你可以把客户端看作前端，把服务器看作后端。
客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。
因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。
本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。

1.什么是 REST API？
REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。
任何遵循 REST 设计原则的 API 都被称为 RESTful API。
简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。
REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下：

2.REST API 设计建议
1. 用名词表示资源
当你设计一个 REST API 时，端点应该使用名词而非动词。
这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。
GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。
因此，举例来说，一个端点不应该是这样的："><meta name=author content="Mumu"><link rel=canonical href=https://blog.q-song.top/posts/restful_api_images/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.q-song.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.q-song.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.q-song.top/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.q-song.top/apple-touch-icon.png><link rel=mask-icon href=https://blog.q-song.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.q-song.top/posts/restful_api_images/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://blog.q-song.top/posts/restful_api_images/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Restful API设计最佳实践?"><meta property="og:description" content="REST API？ REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。 你可以把客户端看作前端，把服务器看作后端。 客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。 因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。 本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。
1.什么是 REST API？ REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。 任何遵循 REST 设计原则的 API 都被称为 RESTful API。 简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。 REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下： 2.REST API 设计建议 1. 用名词表示资源 当你设计一个 REST API 时，端点应该使用名词而非动词。 这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。 GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。 因此，举例来说，一个端点不应该是这样的："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-10T00:00:00+00:00"><meta property="article:tag" content="Restful"><meta name=twitter:card content="summary"><meta name=twitter:title content="Restful API设计最佳实践?"><meta name=twitter:description content="REST API？

REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。
你可以把客户端看作前端，把服务器看作后端。
客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。
因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。
本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。

1.什么是 REST API？
REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。
任何遵循 REST 设计原则的 API 都被称为 RESTful API。
简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。
REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下：

2.REST API 设计建议
1. 用名词表示资源
当你设计一个 REST API 时，端点应该使用名词而非动词。
这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。
GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。
因此，举例来说，一个端点不应该是这样的："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.q-song.top/posts/"},{"@type":"ListItem","position":2,"name":"Restful API设计最佳实践?","item":"https://blog.q-song.top/posts/restful_api_images/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Restful API设计最佳实践?","name":"Restful API设计最佳实践?","description":"REST API？ REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。 你可以把客户端看作前端，把服务器看作后端。 客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。 因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。 本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。\n1.什么是 REST API？ REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。 任何遵循 REST 设计原则的 API 都被称为 RESTful API。 简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。 REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下： 2.REST API 设计建议 1. 用名词表示资源 当你设计一个 REST API 时，端点应该使用名词而非动词。 这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。 GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。 因此，举例来说，一个端点不应该是这样的：\n","keywords":["restful"],"articleBody":"REST API？ REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。 你可以把客户端看作前端，把服务器看作后端。 客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。 因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。 本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。\n1.什么是 REST API？ REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。 任何遵循 REST 设计原则的 API 都被称为 RESTful API。 简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。 REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下： 2.REST API 设计建议 1. 用名词表示资源 当你设计一个 REST API 时，端点应该使用名词而非动词。 这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。 GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。 因此，举例来说，一个端点不应该是这样的：\nhttps://mysite.com/getPosts https://mysite.com/createPost 它应该是这样的：\nhttps://mysite.com/posts 2. 用复数名词表示集合 如果 URL 表示的资源是一个集合应该使用复数名词。 如果你有一个像 https://mysite.com/post/123 这样的端点，用 DELETE 请求删除一个帖子，或用 PUT 或 PATCH 更新一个帖子，可能是可以的，但它没有告诉用户在这个集合中可能还有一些其他帖子。这就是为什么你的集合应该使用复数的名词。 所以，不应该是 https://mysite.com/post/123，而是 https://mysite.com/posts/123。\n3.端点使用嵌套显示关系 很多时候，不同的端点相互联系，所以你应该对它们进行嵌套，这样更容易理解它们。 例如，对于一个多用户博客平台，不同的帖子可能是由不同的作者写的，所以在这种情况下，像 https://mysite.com/posts/author 这样的端点会成为一个有效的嵌套。 同样地，帖子可能有各自的评论，所以要检索评论，可以使用 https://mysite.com/posts/{postId}/comments 这样的端点。 你应该避免超过 3 层的嵌套，因为这可能使 API 不那么优雅，降低可读性。\n4. 用 HTTP 方法操作资源 使用 URL 指定你要用的资源。使用 HTTP 方法来指定怎么处理这个资源。使用五种 HTTP 方法 POST，GET，PUT/PATCH，DELETE 可以提供 CRUD 功能（创建，获取，更新，删除）。 除了 POST 其他请求都具备幂等性（多次请求的效果相同）。需要注意的是 POST 和 PUT 最大的区别就是幂等性，所以 PUT 也可以用于创建操作，只要在创建前就可以确定资源的 ID。\n获取：使用 GET 方法获取资源。GET 请求从不改变资源的状态。无副作用。GET 是幂等的。GET 具有只读的含义。因此，你可以完美的使用缓存。 创建：使用 POST 创建新的资源（非幂等）。 更新：使用 PUT 更新整个资源，PATCH 更新资源部分信息。PUT 和 PATCH 都是幂等的。 删除：使用 DELETE 删除现有资源（幂等）。 简而言之，你应该让 HTTP 动词来处理端点的工作。因此，GET 将检索资源，POST 将创建资源，PUT 将更新整个资源，DELETE 将删除资源，PATCH 更新资源的局部数据。 5. 使用 JSON 作为发送和接收数据的格式 在过去，接受和响应 API 请求主要是通过 XML 甚至 HTML 完成的。但如今，JSON（JavaScript Object Notation）已经在很大程度上成为发送和接收 API 数据的事实格式。 以 XML 为例，对数据进行解码和编码往往有点麻烦，所以 XML 不再受到框架的广泛支持。 例如，JavaScript 有一个内置的方法来通过 fetch API 解析 JSON 数据，因为 JSON 主要是为它而生成的。但是如果你使用任何其他编程语言，如 Python 或 PHP，它们现在也都有解析和操作 JSON 数据的方法。 例如，Python 提供json.load() 和 json.dumps()来处理 JSON 数据。 为了确保客户端正确地解释 JSON 数据，你应该在发出请求时将响应头中的 Content-Type 类型设置为 application/json。 另一方面，对于服务器端的框架，许多框架会自动设置 Content-Type。例如，Express 现在有 express.json() 中间件来实现这一目的。body-parser NPM 包也仍然适用于同一目的。 6. JSON 键命名使用 camelCase 风格 JSON 键命名风格没有统一的标准。 但是最常见有两种，下划线风格的 snake_case 和小驼峰 camelCase。 不同的语言，不同的公司，不同的开源项目均不相同，团队统一即可。 鉴于 REST API 常被 Java 和 JS 实现的客户端调用，且 Java 和 JS 常用 camelCase 来命名 JSON。此外 Google JSON Style Guide 也使用 camelCase，所以推荐使用 camelCase 格式命名 JSON 键。 7. 使用统一的回包格式，将实际数据包装在 data 字段中 接口回包时我们应该使用统一的回包格式，将实际数据包装在 data 字段中。\n{ \"code\": 0, \"msg\": \"ok\", \"data\":{} } 比如查询某个帖子详情 GET https://mysite.com/posts/{id}回包内容可以是：\n{ \"code\": 0, \"msg\": \"ok\", \"data\": { \"post\": {\"id\":1, \"content\":\"xxx\"} } } 其中 code 为 0 表示成功，非 0 表示失败，并在 msg 中记录详细的错误信息。 分页接口回包 data 结构包含 total 总记录数。 比如分页拉取帖子详情。\n{ \"code\": 0, \"msg\": \"ok\", \"data\": { \"total\": 100, \"posts\": [ {\"id\":1, \"content\":\"xxx\"}, {\"id\":2, \"content\":\"xxx\"}, {\"id\":3, \"content\":\"xxx\"} ] } } 8. 非资源请求用动词 有时 API 调用并不涉及资源，比如计算、翻译或转换等。\nGET /translate?from=de\u0026to=en\u0026text=Hallo GET /calculate?param1=23¶m2=432 在这种情况下，API 响应不会返回任何资源，而是执行一个操作并将结果返回给客户端。因此，我们应该在 URL 中使用动词而不是名词，来清楚地区分资源请求和非资源请求。\n9. 分页返回数据 有时 API 获取的数据可能非常大，一次性返回所有数据是一个糟糕的做法，因为这会带来严重的性能问题和不必要的带宽浪费。 所以，我们应该分页返回数据。 分页返回，常见的实现方式是在 API 参数中提供 page 和 size（offset 和 limit）或 after_id 和 limit。 page 与 size 适合数据总量小的浅分页查询，after_id 和 limit 适合数据总量大的深分页查询。\n// 浅分页 GET https://mysite.com/posts?page=PAGE\u0026size=SIZE // 深分页 GET https://mysite.com/posts?after_id=AFTER_ID\u0026limit=LIMIT 10. 考虑特定资源搜索和跨资源搜索 * 提供对特定资源的搜索很容易。只需使用相应的资源集合 URL，并将搜索字符串附加到查询参数中即可。 ```` GET /employees?query ```` * 如果要对所有资源提供全局搜索，则需要用其他方法。前文提到，对于非资源请求 URL，使用动词而非名词。因此，您的搜索网址可能如下所示： ```` GET /search?query=Paul // 返回 employees, customers, suppliers 等等。 ```` 11. URL Path 使用连字符分隔单词 一个合法的 HTTP URL 组成格式如下：\nhttp(s)://:/?# Path 如何分隔单词？REST API 的最佳实践是使用连字符（hyphen），而不是下划线（underscore）或驼峰（camelcase）。这是来自 Mark Masse 的《REST API Design Rulebook》的建议。 此外，搜索引擎也更喜欢使用连字符来分隔单词，使用连字符分隔单词，它们让搜索引擎更准确地理解 URL 中的单词和短语，这样搜索引擎就可以索引单个单词，有助于 SEO，很容易检索到这个 URL，排名靠前。 许多著名公司都遵循该实践方式，如 Stack Overflow。 如一个使用连字符的 REST API URL 可能如下所示： https://api.example.com/users/john-doe 而使用下划线的 URL 则可能如下所示：\nhttps://api.example.com/users/john_doe 虽然两者在技术上都是有效的 URL，但前者更符合 REST API 的最佳实践。\n12. URL Query 使用下划线分隔单词 查询字符串是 URL 的组成部分。URL 规范规定查询字符串的不同参数使用与号（\u0026）分隔，参数名与值使用等号（=）分隔。 当我们在 URL Query 中命名参数名称与值时，建议使用下划线。 如一个使用下划线的查询参数可能如下所示：\nfirst_name=john\u0026last_name=doe 而使用连字符的查询参数则可能如下所示：\nfirst-name=john\u0026last-name=doe 虽然在技术上两者都是有效的，但使用下划线表示被连接的不同单词是一个整体，更符合 REST API 的最佳实践，并且更容易读写和阅读。 当然这不是绝对的，对于一些复杂的情况，下划线和连字符可以混用。\nname_birthdate=john_doe-2023_06_09 其中 john_doe 表示一个整体，2023_06_09 表示一个整体，二者通过连字符分隔。\n13. 使用 HTTP 状态码 你应该在对你的 API 请求的响应中始终使用常规的 HTTP 状态代码。这将帮助你的用户知道发生了什么——请求是否成功，或者是否失败，或者其他情况。 下面的表格显示了不同的 HTTP 状态代码范围和它们的含义： HTTP 状态码速查表 类别 状态码 状态描述 (Reason Phrase) 含义与应用场景 1xx 100 Continue 继续：服务器已收到请求头，客户端应继续发送请求体。 信息 101 Switching Protocols 切换协议：升级为 WebSocket 等协议。 — — — — 2xx 200 OK 成功：请求已正常处理。 成功 201 Created 已创建：成功创建了新资源（如 POST 创建用户）。 204 No Content 无内容：处理成功但无需返回数据（如删除资源）。 206 Partial Content 部分内容：范围请求成功（如断点续传、分段下载）。 — — — — 3xx 301 Moved Permanently 永久重定向：资源已永久移动到新 URL。 重定向 302 Found 临时重定向：资源临时移动，SEO 不会更新权重。 304 Not Modified 未修改：使用本地缓存，不返回资源。 — — — — 4xx 400 Bad Request 错误请求：语义有误或参数错误，服务器无法理解。 客户端 401 Unauthorized 未授权：需要进行身份验证。 错误 403 Forbidden 禁止：服务器拒绝执行（通常是权限不够）。 404 Not Found 未找到：服务器上找不到请求的资源。 405 Method Not Allowed 方法禁用：如接口只支持 GET，你用了 POST。 429 Too Many Requests 请求过多：触发了 API 的频率限制。 — — — — 5xx 500 Internal Server Error 服务器内部错误：代码报错、数据库挂了等。 服务器 502 Bad Gateway 网关错误：Nginx 转发到了一个失效的后端服务。 错误 503 Service Unavailable 服务不可用：服务器超载或正在维护。 504 Gateway Timeout 网关超时：后端处理太慢，导致网关等待超时。 常用: 200 OK: 一切正常。 301 vs 302: 永久重定向（SEO 权重转移） vs 临时重定向。 403 vs 404: 拒绝访问（有资源但没权限） vs 找不到资源。 500: 代码写错了，或者服务器炸了。 502 vs 504: 网关收到错误响应 vs 网关没收到响应（超时）。 简略: 1 (Informational): 正在响应（信息中转） 2 (Success): 已经成功 3 (Redirection): 需要重定向 4 (Client Error): 是客户端的错 5 (Server Error): 是服务器的错 14. 提供有用的错误消息 除了提供恰当的 HTTP 状态代码外，还应该在 HTTP 响应正文中提供有用且详细的错误描述。 比如GET /mysite.com/posts?category=unknow\u0026page=1\u0026size=10 请求，如果入参有误，应该准确告知调用方。 // 400 Bad Request { \"code\": 10000, \"msg\":\"Invalid category. Valid values are 'biz' or 'tech'\" } 15. 明确版本划分 REST API 应该有不同的版本，因为如果有不兼容和破坏性的更改，版本号将让你能更容易发布 API，且不会破坏用户的应用程序。 划分 API 版本，常见的做法是在 URL Path 中加入版本标识。 /v1/employees /v2/employees 许多科技巨头和个人的 REST API 通常是这样做的，例如 Facebook 与 Spotify 当您以这种方式提供 REST API 时，您不需要强迫客户端迁移到新版本，如果他们不想迁移的话。\n16. 使用 HATEOAS API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在响应中给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。 HATEOAS 是 Hypermedia As The Engine Of Application State 的缩写，从字面上理解是 “超媒体即是应用状态引擎” 。其原则就是客户端与服务器的交互完全由超媒体动态提供，客户端无需事先了解如何与数据或服务器交互。相反的，在一些 RPC 服务或 Redis、MySQL 等软件，需要事先了解接口定义或特定的交互语法。\n举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。\n{ ... \"feeds_url\": \"https://api.github.com/feeds\", \"followers_url\": \"https://api.github.com/user/followers\", \"following_url\": \"https://api.github.com/user/following{/target}\", \"gists_url\": \"https://api.github.com/gists{/gist_id}\", \"hub_url\": \"https://api.github.com/hub\", ... } 上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。\n17. 提供准确的 API 文档 当你创建 REST API 时，你需要帮助用户（消费者）正确学习并了解如何使用它。最好的方法是为 API 提供良好的文档。 文档应包含：\nAPI 的相关端点 端点的示例请求 在几种编程语言中的实现 不同错误的消息列表及其状态代码 你可以用于 API 文档的最常用工具是 Swagger。你也可以使用 Postman 来记录你的 API，这是软件开发中最常见的 API 测试工具。\n18. 使用 TLS 保障安全 TLS（Transport Layer Security）指的是传输层安全协议。这对 REST API 的安全性至关重要。使用 SSL 可以保护你的 API，使其更不容易受到恶意攻击。 TLS 证书不难加载到服务器上，而且大多数情况下在第一年是免费的。即使需要购买，它们也并不昂贵。\n运行在 TLS 上的 REST API 的 URL 与不运行在 TLS 上的 URL 的明显区别是协议 HTTP 中是否包含 s，https://mysite.com/posts 运行在 TLS 上，http://mysite.com/posts 不运行在 TLS 上。\n你还应考虑其他安全措施，比如对请求做身份校验。\n19. 使用统一的错误码 同一个服务的不同 API 或不同系统模块的不同服务的 API 应该使用统一的错误码。 统一的错误码有很多优势。 * 易于维护： 统一的错误码可以使 API 的维护更加简单。当需要调整错误信息或添加新的错误时，只需修改一处错误码定义即可，而无需在整个 API 中查找和修改多处。 * 对调用方友好： 使用统一的错误码可以降低客户端开发的难度。客户端只需关注预定义的错误码，而无需解析和处理不同形式的错误响应。 * 错误诊断和日志记录： 统一的错误码可以帮助开发人员更轻松地诊断 API 中的问题。错误日志中使用统一的错误码可以提供更准确的错误信息，帮助定位和解决问题。 在实际应用中，需要根据具体业务场景来选择合适的错误码策略。错误码的设计应该符合 API 的业务逻辑和语义，同时也需要与客户端开发人员进行充分的沟通和协商。 下面是一些常见的错误。\ncode 说明 10000 入参有误 10001 Token 非法 10002 请求处理超时 10003 记录未找到 10004 DB 写入失败 10005 DB 更新失败 10006 DB 查询失败 10007 DB 删除失败 10008 JSON 序列化失败 10009 JSON 反序列化失败 关于错误码的定义，一般没有固定的规定，不同的系统和应用可能会采用不同的错误码起始值。错误码的起始值通常是根据具体需求和规模来确定的。 比如在大规模的系统中，可能会选择更大的错误码起始值，从 10000、100000 开始，以便在未来可以灵活地添加更多的错误码。\n3.一个文章API设计 一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 REST 中这就相当于通用的模板。\n例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种：\nGET /articles： 文章列表 GET /articles/{id}：文章详情 POST /articles： 创建文章 PUT /articles/{id}：修改文章 PATCH /articles/{id}：修改文章的部分信息 DELETE /articles/{id}：删除文章 将文章 ID 放在 Path 而不是 Query 中的一个好处是可以表示资源之间的层级关系。 例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于某一篇文章，所以它们的 URL 应该是下面这样的。\nGET /comments/{id}： 获取单个评论 GET /articles/{id}/comments： 某篇文章的评论列表 POST /articles/{id}/comments： 为篇文章创建评论 PUT /comments/{id}： 修改评论 PATCH /comments/{id}： 修改评论的部分信息 DELETE /comments/{id}： 删除评论 这里有一点比较特殊，永远使用可以指向资源最短的 URL，也就是说既然 /comments/{id} 可以指向一条评论了，就不要用 /articles/{id}/comments/{id} 特意指出所属文章了。\nGET\t/articles/{id}/like：查看文章是否被点赞 PUT\t/articles/{id}/like：点赞文章 DELETE /articles/{id}/like：取消点赞 注意，点赞文章我选择了 PUT 而不是 POST，因为我觉得点赞这种行为应该是幂等的，多次操作的结果应该相同。另外，是否点赞可以直接在获取文章详情时返回，而不用单独写一个接口。\n4.REST API常见问题 4.1 批量新增接口如何设计？ 使用复数形式的资源名称来表示批量新增多个资源的操作，这与新增单个的接口存在冲突，不建议使用。在资源路径后添加一个表示批量操作的子路径，含义简洁明了，建议使用。\n// 不推荐 POST /resources // 推荐 POST /resources/batch 4.2 批量查询接口如何设计？ 根据 ID 获取单个资源可以使用如下 URL。\nGET /resources/{id} 如果需要根据 ID 同时删除多个资源，URL 该如何设计呢？ 常见的方式有如下几种。\n第一种：Path 传参。 使用 GET 方法，多个资源 ID 放进 URL Path 中。\nGET /resources/ids/1,2,3... 使用 GET 方法时，将多个资源 ID 放到 Path 中传递，并且在路径中加入 ids 标识和单个 ID 接口区分开来。路径中的资源 ID 更具语义化且更具可读性，建议使用。\n第二种：Query 传参。 使用 GET 方法，用多个资源 ID 放进 URL Query 中。\nGET /resources?ids=1,2,3... 查询参数可以方便地与其他查询参数一起使用，进行过滤、排序和分页等操作。不过将多个 ID 放到 Query 传递，查询参数不够直观，需要在文档中明确指出如何传递多个 ID。\n注意，由于浏览器和服务器一般对 URL 的长度存在限制（没有统一标准上限，一般为 8192 字节），上面两种方式如果操作的资源过多无法实现。从实际来看，一般批量操作时需要为 ID 数设置一个上限，这样便不会触及 URL 的上限。\n第三种：Body 传参。 使用 GET 方法，用多个资源 ID 放进请求体中。\nGET /resources Content-Type: application/json { \"ids\":[1,2,3] } 虽然 HTTP 规范允许 GET 请求发送请求体，但大多数 Web 服务器和客户端库在处理 GET 请求时会忽略请求体。也就是说，大多数 Web 服务器和客户端库并不期望在 GET 请求中包含请求体，并且可能会忽略或拒绝处理请求体中的数据。 HTTP/1.1 规范（RFC 7231）中指出：\nA payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.\n也就是说 HTTP/1.1 规范虽然允许 GET 请求发送请求体，但是不建议这么做，因为 GET 请求被定义为获取资源的操作，而不是在请求体中发送数据。\n根据 RESTful 设计准则，对于 GET 请求，也不应将请求参数放在请求体中。GET 请求的查询参数应该直接放在 URL 中，而不是放在请求体中。\n第四种：POST + Body 传参。 使用 POST 方法，将多个 ID 封装在请求体中。请求体可以是 JSON 或其他格式的数据，用于传递多个 ID。\nPOST /resources Content-Type: application/json { \"ids\": [1, 2, 3] } 由于 POST 语义上不符合实际的查询动作，所以建议使用 GET 方法。\n3. 批量删除接口如何设计？ 删除单个资源可以在 URL Path 中指定资源 ID。\nDELETE /resources/{id} 如果需要根据 ID 同时删除多个资源，URL 该如何设计呢？ 常见的方式有如下几种。\n第一种：Path 传参。 使用 DELETE 方法，用逗号分隔将多个资源 ID 放进 URL Path 中。\nDELETE /resources/ids/1,2,3... 将多个 ID 放到 Path 传递，并且在路径中加入 ids 标识和单个 ID 接口区分开来，清晰明了，建议使用。\n第二种：Query 传参。 使用 DELETE 方法，用多个资源 ID 放进 URL Query 中。\nDELETE /resources?ids=1,2,3... 将多个 ID 放到 Query 传递，查询参数不够直观，需要在文档中明确指出如何传递多个 ID。\n注意，由于浏览器和服务器一般对 URL 的长度存在限制（没有统一标准上限，一般为 8192 字节），上面两种方式如果操作的资源过多无法实现。\n实际上批量删除操作本身是一个非常敏感的操作，一般会对批量删除资源的数量做严格限制，所以不会出现太长的 URL。\n第三种：Body 传参。 使用 DELETE 方法，将需要删除的资源的 ID 放到请求体里面。\nDELETE /resources { \"ids\":[1,2,3...] } HTTP 协议标准并没有规定 DELETE 请求不能带 Body，但是 DELETE 请求体在语义上没有意义，一些网关、代理、防火墙在收到 DELETE 请求后，会把请求的 Body 直接剥离掉，所以不建议 DELETE 携带 Body。\n第四种：POST + Body 传参。 改用 POST 方法，将需要删除资源的 ID 放到请求体。\nPOST /resources Content-Type: application/json { \"method\": \"delete\", \"ids\": [1, 2, 3] } 使用 POST 语义上与删除动作不符。\n","wordCount":"1216","inLanguage":"zh","datePublished":"2025-12-10T00:00:00Z","dateModified":"2025-12-10T00:00:00Z","author":{"@type":"Person","name":"Mumu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.q-song.top/posts/restful_api_images/"},"publisher":{"@type":"Organization","name":"Q-song | 技术.生活.阅读.思考","logo":{"@type":"ImageObject","url":"https://blog.q-song.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.q-song.top/ accesskey=h title="Q-song (Alt + H)"><img src=https://blog.q-song.top/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.q-song.top/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://blog.q-song.top/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://blog.q-song.top/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://blog.q-song.top/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://blog.q-song.top/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Restful API设计最佳实践?</h1><div class=post-meta><span title='2025-12-10 00:00:00 +0000 UTC'>2025年12月10日</span>&nbsp;·&nbsp;<span>Mumu</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><ul><ul><li><a href=#rest-api aria-label="REST API？">REST API？</a></li><li><a href=#1%e4%bb%80%e4%b9%88%e6%98%af-rest-api aria-label="1.什么是 REST API？">1.什么是 REST API？</a></li><li><a href=#2rest-api-%e8%ae%be%e8%ae%a1%e5%bb%ba%e8%ae%ae aria-label="2.REST API 设计建议">2.REST API 设计建议</a><ul><li><a href=#1-%e7%94%a8%e5%90%8d%e8%af%8d%e8%a1%a8%e7%a4%ba%e8%b5%84%e6%ba%90 aria-label="1. 用名词表示资源">1. 用名词表示资源</a></li><li><a href=#2-%e7%94%a8%e5%a4%8d%e6%95%b0%e5%90%8d%e8%af%8d%e8%a1%a8%e7%a4%ba%e9%9b%86%e5%90%88 aria-label="2. 用复数名词表示集合">2. 用复数名词表示集合</a></li><li><a href=#3%e7%ab%af%e7%82%b9%e4%bd%bf%e7%94%a8%e5%b5%8c%e5%a5%97%e6%98%be%e7%a4%ba%e5%85%b3%e7%b3%bb aria-label=3.端点使用嵌套显示关系>3.端点使用嵌套显示关系</a></li><li><a href=#4-%e7%94%a8-http-%e6%96%b9%e6%b3%95%e6%93%8d%e4%bd%9c%e8%b5%84%e6%ba%90 aria-label="4. 用 HTTP 方法操作资源">4. 用 HTTP 方法操作资源</a></li><li><a href=#5-%e4%bd%bf%e7%94%a8-json-%e4%bd%9c%e4%b8%ba%e5%8f%91%e9%80%81%e5%92%8c%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae%e7%9a%84%e6%a0%bc%e5%bc%8f aria-label="5. 使用 JSON 作为发送和接收数据的格式">5. 使用 JSON 作为发送和接收数据的格式</a></li><li><a href=#6-json-%e9%94%ae%e5%91%bd%e5%90%8d%e4%bd%bf%e7%94%a8-camelcase-%e9%a3%8e%e6%a0%bc aria-label="6. JSON 键命名使用 camelCase 风格">6. JSON 键命名使用 camelCase 风格</a></li><li><a href=#7-%e4%bd%bf%e7%94%a8%e7%bb%9f%e4%b8%80%e7%9a%84%e5%9b%9e%e5%8c%85%e6%a0%bc%e5%bc%8f%e5%b0%86%e5%ae%9e%e9%99%85%e6%95%b0%e6%8d%ae%e5%8c%85%e8%a3%85%e5%9c%a8-data-%e5%ad%97%e6%ae%b5%e4%b8%ad aria-label="7. 使用统一的回包格式，将实际数据包装在 data 字段中">7. 使用统一的回包格式，将实际数据包装在 data 字段中</a></li><li><a href=#8-%e9%9d%9e%e8%b5%84%e6%ba%90%e8%af%b7%e6%b1%82%e7%94%a8%e5%8a%a8%e8%af%8d aria-label="8. 非资源请求用动词">8. 非资源请求用动词</a></li><li><a href=#9-%e5%88%86%e9%a1%b5%e8%bf%94%e5%9b%9e%e6%95%b0%e6%8d%ae aria-label="9. 分页返回数据">9. 分页返回数据</a></li><li><a href=#10-%e8%80%83%e8%99%91%e7%89%b9%e5%ae%9a%e8%b5%84%e6%ba%90%e6%90%9c%e7%b4%a2%e5%92%8c%e8%b7%a8%e8%b5%84%e6%ba%90%e6%90%9c%e7%b4%a2 aria-label="10. 考虑特定资源搜索和跨资源搜索">10. 考虑特定资源搜索和跨资源搜索</a></li><li><a href=#11-url-path-%e4%bd%bf%e7%94%a8%e8%bf%9e%e5%ad%97%e7%ac%a6%e5%88%86%e9%9a%94%e5%8d%95%e8%af%8d aria-label="11. URL Path 使用连字符分隔单词">11. URL Path 使用连字符分隔单词</a></li><li><a href=#12-url-query-%e4%bd%bf%e7%94%a8%e4%b8%8b%e5%88%92%e7%ba%bf%e5%88%86%e9%9a%94%e5%8d%95%e8%af%8d aria-label="12. URL Query 使用下划线分隔单词">12. URL Query 使用下划线分隔单词</a></li><li><a href=#13-%e4%bd%bf%e7%94%a8-http-%e7%8a%b6%e6%80%81%e7%a0%81 aria-label="13. 使用 HTTP 状态码">13. 使用 HTTP 状态码</a></li></ul></li></ul></ul><li><a href=#http-%e7%8a%b6%e6%80%81%e7%a0%81%e9%80%9f%e6%9f%a5%e8%a1%a8 aria-label="HTTP 状态码速查表">HTTP 状态码速查表</a><ul><ul><ul><li><a href=#14-%e6%8f%90%e4%be%9b%e6%9c%89%e7%94%a8%e7%9a%84%e9%94%99%e8%af%af%e6%b6%88%e6%81%af aria-label="14. 提供有用的错误消息">14. 提供有用的错误消息</a></li><li><a href=#15-%e6%98%8e%e7%a1%ae%e7%89%88%e6%9c%ac%e5%88%92%e5%88%86 aria-label="15. 明确版本划分">15. 明确版本划分</a></li><li><a href=#16-%e4%bd%bf%e7%94%a8-hateoas aria-label="16. 使用 HATEOAS">16. 使用 HATEOAS</a></li><li><a href=#17-%e6%8f%90%e4%be%9b%e5%87%86%e7%a1%ae%e7%9a%84-api-%e6%96%87%e6%a1%a3 aria-label="17. 提供准确的 API 文档">17. 提供准确的 API 文档</a></li><li><a href=#18-%e4%bd%bf%e7%94%a8-tls-%e4%bf%9d%e9%9a%9c%e5%ae%89%e5%85%a8 aria-label="18. 使用 TLS 保障安全">18. 使用 TLS 保障安全</a></li><li><a href=#19-%e4%bd%bf%e7%94%a8%e7%bb%9f%e4%b8%80%e7%9a%84%e9%94%99%e8%af%af%e7%a0%81 aria-label="19. 使用统一的错误码">19. 使用统一的错误码</a></li></ul><li><a href=#3%e4%b8%80%e4%b8%aa%e6%96%87%e7%ab%a0api%e8%ae%be%e8%ae%a1 aria-label=3.一个文章API设计>3.一个文章API设计</a></li><li><a href=#4rest-api%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98 aria-label="4.REST API常见问题">4.REST API常见问题</a><ul><li><a href=#41-%e6%89%b9%e9%87%8f%e6%96%b0%e5%a2%9e%e6%8e%a5%e5%8f%a3%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label="4.1 批量新增接口如何设计？">4.1 批量新增接口如何设计？</a></li><li><a href=#42-%e6%89%b9%e9%87%8f%e6%9f%a5%e8%af%a2%e6%8e%a5%e5%8f%a3%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label="4.2 批量查询接口如何设计？">4.2 批量查询接口如何设计？</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e7%a7%8dpath-%e4%bc%a0%e5%8f%82 aria-label="第一种：Path 传参。">第一种：Path 传参。</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%a7%8dquery-%e4%bc%a0%e5%8f%82 aria-label="第二种：Query 传参。">第二种：Query 传参。</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e7%a7%8dbody-%e4%bc%a0%e5%8f%82 aria-label="第三种：Body 传参。">第三种：Body 传参。</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e7%a7%8dpost--body-%e4%bc%a0%e5%8f%82 aria-label="第四种：POST + Body 传参。">第四种：POST + Body 传参。</a></li></ul></li><li><a href=#3-%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e6%8e%a5%e5%8f%a3%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label="3. 批量删除接口如何设计？">3. 批量删除接口如何设计？</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e7%a7%8dpath-%e4%bc%a0%e5%8f%82-1 aria-label="第一种：Path 传参。">第一种：Path 传参。</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%a7%8dquery-%e4%bc%a0%e5%8f%82-1 aria-label="第二种：Query 传参。">第二种：Query 传参。</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e7%a7%8dbody-%e4%bc%a0%e5%8f%82-1 aria-label="第三种：Body 传参。">第三种：Body 传参。</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e7%a7%8dpost--body-%e4%bc%a0%e5%8f%82-1 aria-label="第四种：POST + Body 传参。">第四种：POST + Body 传参。</a></li></ul></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h3 id=rest-api>REST API？<a hidden class=anchor aria-hidden=true href=#rest-api>#</a></h3><blockquote><p>REST API 是当今最常见的 Web 接口形式之一 ，在确保客户端和服务器之间的顺利通信方面发挥了重要作用。
你可以把客户端看作前端，把服务器看作后端。
客户端（前端）和服务器（后端）之间的通信通常不是直接的。因此，我们使用 API（应用编程接口），作为客户端和服务器之间的中介。
因为 API 在这种 client–server 通信中起着至关重要的作用，所以我们在设计 API 时应该遵循最佳实践。这有助于开发人员更好地维护和使用它们。
本篇通过 REST API 时可以遵循的一些最佳实践。这将帮助创建高效，安全，易于使用和维护的 API。</p></blockquote><h3 id=1什么是-rest-api>1.什么是 REST API？<a hidden class=anchor aria-hidden=true href=#1什么是-rest-api>#</a></h3><p>REST 是 Representational State Transfer 的缩写。它是由 Roy Fielding 博士在 2000 年他的博士论文中提出一种软件架构风格，用于指导网络应用的设计和开发，使得 Web API（网络应用编程接口）更加简单、灵活、可扩展和易于理解。
任何遵循 REST 设计原则的 API 都被称为 RESTful API。
简单地说，REST API 是两台计算机通过 HTTP（超文本传输协议）进行通信的媒介，与客户端和服务器的通信方式相同。
REST API 使用 URL 唯一标识和定位 RESTful 服务中的资源，一个完整的 URL 结构如下：
<img loading=lazy src=/posts/restful_api_images/0699d80f.png></p><h3 id=2rest-api-设计建议>2.REST API 设计建议<a hidden class=anchor aria-hidden=true href=#2rest-api-设计建议>#</a></h3><h4 id=1-用名词表示资源>1. 用名词表示资源<a hidden class=anchor aria-hidden=true href=#1-用名词表示资源>#</a></h4><p>当你设计一个 REST API 时，端点应该使用名词而非动词。
这是因为 HTTP 方法已经以动词形式执行基本的 CRUD（创建、读取、更新、删除）操作。
GET、POST、PUT、PATCH 和 DELETE 是最常见的 HTTP 动词。还有其他非 HTTP 标准动词，如 COPY、PURGE、LINK、UNLINK 等等。
因此，举例来说，一个端点不应该是这样的：</p><pre tabindex=0><code>https://mysite.com/getPosts
https://mysite.com/createPost
</code></pre><p>它应该是这样的：</p><pre tabindex=0><code>https://mysite.com/posts
</code></pre><h4 id=2-用复数名词表示集合>2. 用复数名词表示集合<a hidden class=anchor aria-hidden=true href=#2-用复数名词表示集合>#</a></h4><p>如果 URL 表示的资源是一个集合应该使用复数名词。
如果你有一个像 <a href=https://mysite.com/post/123>https://mysite.com/post/123</a> 这样的端点，用 DELETE 请求删除一个帖子，或用 PUT 或 PATCH 更新一个帖子，可能是可以的，但它没有告诉用户在这个集合中可能还有一些其他帖子。这就是为什么你的集合应该使用复数的名词。
所以，不应该是 <a href=https://mysite.com/post/123>https://mysite.com/post/123</a>，而是 <a href=https://mysite.com/posts/123>https://mysite.com/posts/123</a>。</p><h4 id=3端点使用嵌套显示关系>3.端点使用嵌套显示关系<a hidden class=anchor aria-hidden=true href=#3端点使用嵌套显示关系>#</a></h4><p>很多时候，不同的端点相互联系，所以你应该对它们进行嵌套，这样更容易理解它们。
例如，对于一个多用户博客平台，不同的帖子可能是由不同的作者写的，所以在这种情况下，像 <a href=https://mysite.com/posts/author>https://mysite.com/posts/author</a> 这样的端点会成为一个有效的嵌套。
同样地，帖子可能有各自的评论，所以要检索评论，可以使用 <a href=https://mysite.com/posts/%7BpostId%7D/comments>https://mysite.com/posts/{postId}/comments</a> 这样的端点。
你应该避免超过 3 层的嵌套，因为这可能使 API 不那么优雅，降低可读性。</p><h4 id=4-用-http-方法操作资源>4. 用 HTTP 方法操作资源<a hidden class=anchor aria-hidden=true href=#4-用-http-方法操作资源>#</a></h4><p>使用 URL 指定你要用的资源。使用 HTTP 方法来指定怎么处理这个资源。使用五种 HTTP 方法 POST，GET，PUT/PATCH，DELETE 可以提供 CRUD 功能（创建，获取，更新，删除）。
除了 POST 其他请求都具备幂等性（多次请求的效果相同）。需要注意的是 POST 和 PUT 最大的区别就是幂等性，所以 PUT 也可以用于创建操作，只要在创建前就可以确定资源的 ID。</p><ul><li>获取：使用 GET 方法获取资源。GET 请求从不改变资源的状态。无副作用。GET 是幂等的。GET 具有只读的含义。因此，你可以完美的使用缓存。</li><li>创建：使用 POST 创建新的资源（非幂等）。</li><li>更新：使用 PUT 更新整个资源，PATCH 更新资源部分信息。PUT 和 PATCH 都是幂等的。</li><li>删除：使用 DELETE 删除现有资源（幂等）。</li><li>简而言之，你应该让 HTTP 动词来处理端点的工作。因此，GET 将检索资源，POST 将创建资源，PUT 将更新整个资源，DELETE 将删除资源，PATCH 更新资源的局部数据。</li></ul><h4 id=5-使用-json-作为发送和接收数据的格式>5. 使用 JSON 作为发送和接收数据的格式<a hidden class=anchor aria-hidden=true href=#5-使用-json-作为发送和接收数据的格式>#</a></h4><ul><li>在过去，接受和响应 API 请求主要是通过 XML 甚至 HTML 完成的。但如今，JSON（JavaScript Object Notation）已经在很大程度上成为发送和接收 API 数据的事实格式。
以 XML 为例，对数据进行解码和编码往往有点麻烦，所以 XML 不再受到框架的广泛支持。</li><li>例如，JavaScript 有一个内置的方法来通过 fetch API 解析 JSON 数据，因为 JSON 主要是为它而生成的。但是如果你使用任何其他编程语言，如 Python 或 PHP，它们现在也都有解析和操作 JSON 数据的方法。</li><li>例如，Python 提供json.load() 和 json.dumps()来处理 JSON 数据。
为了确保客户端正确地解释 JSON 数据，你应该在发出请求时将响应头中的 Content-Type 类型设置为 application/json。</li><li>另一方面，对于服务器端的框架，许多框架会自动设置 Content-Type。例如，Express 现在有 express.json() 中间件来实现这一目的。body-parser NPM 包也仍然适用于同一目的。</li></ul><h4 id=6-json-键命名使用-camelcase-风格>6. JSON 键命名使用 camelCase 风格<a hidden class=anchor aria-hidden=true href=#6-json-键命名使用-camelcase-风格>#</a></h4><ul><li>JSON 键命名风格没有统一的标准。</li><li>但是最常见有两种，下划线风格的 snake_case 和小驼峰 camelCase。</li><li>不同的语言，不同的公司，不同的开源项目均不相同，团队统一即可。</li><li>鉴于 REST API 常被 Java 和 JS 实现的客户端调用，且 Java 和 JS 常用 camelCase 来命名 JSON。此外 Google JSON Style Guide 也使用 camelCase，所以推荐使用 camelCase 格式命名 JSON 键。</li></ul><h4 id=7-使用统一的回包格式将实际数据包装在-data-字段中>7. 使用统一的回包格式，将实际数据包装在 data 字段中<a hidden class=anchor aria-hidden=true href=#7-使用统一的回包格式将实际数据包装在-data-字段中>#</a></h4><p>接口回包时我们应该使用统一的回包格式，将实际数据包装在 data 字段中。</p><pre tabindex=0><code>{
  &#34;code&#34;: 0,
  &#34;msg&#34;: &#34;ok&#34;,
  &#34;data&#34;:{}
}
</code></pre><p>比如查询某个帖子详情 GET <a href=https://mysite.com/posts/%7Bid%7D>https://mysite.com/posts/{id}</a>回包内容可以是：</p><pre tabindex=0><code>{
  &#34;code&#34;: 0,
  &#34;msg&#34;: &#34;ok&#34;,
  &#34;data&#34;: {
    &#34;post&#34;: {&#34;id&#34;:1, &#34;content&#34;:&#34;xxx&#34;}
  }
}
</code></pre><p>其中 code 为 0 表示成功，非 0 表示失败，并在 msg 中记录详细的错误信息。
分页接口回包 data 结构包含 total 总记录数。
比如分页拉取帖子详情。</p><pre tabindex=0><code>{
  &#34;code&#34;: 0,
  &#34;msg&#34;: &#34;ok&#34;,
  &#34;data&#34;: {
    &#34;total&#34;: 100,
    &#34;posts&#34;: [
      {&#34;id&#34;:1, &#34;content&#34;:&#34;xxx&#34;},
      {&#34;id&#34;:2, &#34;content&#34;:&#34;xxx&#34;},
      {&#34;id&#34;:3, &#34;content&#34;:&#34;xxx&#34;}
    ]
  }
}
</code></pre><h4 id=8-非资源请求用动词>8. 非资源请求用动词<a hidden class=anchor aria-hidden=true href=#8-非资源请求用动词>#</a></h4><p>有时 API 调用并不涉及资源，比如计算、翻译或转换等。</p><pre tabindex=0><code>GET /translate?from=de&amp;to=en&amp;text=Hallo
GET /calculate?param1=23¶m2=432
</code></pre><p>在这种情况下，API 响应不会返回任何资源，而是执行一个操作并将结果返回给客户端。因此，我们应该在 URL 中使用动词而不是名词，来清楚地区分资源请求和非资源请求。</p><h4 id=9-分页返回数据>9. 分页返回数据<a hidden class=anchor aria-hidden=true href=#9-分页返回数据>#</a></h4><p>有时 API 获取的数据可能非常大，一次性返回所有数据是一个糟糕的做法，因为这会带来严重的性能问题和不必要的带宽浪费。
所以，我们应该分页返回数据。
分页返回，常见的实现方式是在 API 参数中提供 page 和 size（offset 和 limit）或 after_id 和 limit。
page 与 size 适合数据总量小的浅分页查询，after_id 和 limit 适合数据总量大的深分页查询。</p><pre tabindex=0><code>// 浅分页
GET https://mysite.com/posts?page=PAGE&amp;size=SIZE
// 深分页
GET https://mysite.com/posts?after_id=AFTER_ID&amp;limit=LIMIT
</code></pre><h4 id=10-考虑特定资源搜索和跨资源搜索>10. 考虑特定资源搜索和跨资源搜索<a hidden class=anchor aria-hidden=true href=#10-考虑特定资源搜索和跨资源搜索>#</a></h4><pre><code>* 提供对特定资源的搜索很容易。只需使用相应的资源集合 URL，并将搜索字符串附加到查询参数中即可。
````
GET /employees?query
````
* 如果要对所有资源提供全局搜索，则需要用其他方法。前文提到，对于非资源请求 URL，使用动词而非名词。因此，您的搜索网址可能如下所示：
````
GET /search?query=Paul   // 返回 employees, customers, suppliers 等等。
````
</code></pre><h4 id=11-url-path-使用连字符分隔单词>11. URL Path 使用连字符分隔单词<a hidden class=anchor aria-hidden=true href=#11-url-path-使用连字符分隔单词>#</a></h4><p>一个合法的 HTTP URL 组成格式如下：</p><pre tabindex=0><code>http(s)://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;
</code></pre><ul><li>Path 如何分隔单词？REST API 的最佳实践是使用连字符（hyphen），而不是下划线（underscore）或驼峰（camelcase）。这是来自 Mark Masse 的《REST API Design Rulebook》的建议。</li><li>此外，搜索引擎也更喜欢使用连字符来分隔单词，使用连字符分隔单词，它们让搜索引擎更准确地理解 URL 中的单词和短语，这样搜索引擎就可以索引单个单词，有助于 SEO，很容易检索到这个 URL，排名靠前。
许多著名公司都遵循该实践方式，如 Stack Overflow。
如一个使用连字符的 REST API URL 可能如下所示：</li></ul><pre tabindex=0><code>https://api.example.com/users/john-doe
</code></pre><p>而使用下划线的 URL 则可能如下所示：</p><pre tabindex=0><code>https://api.example.com/users/john_doe
</code></pre><p>虽然两者在技术上都是有效的 URL，但前者更符合 REST API 的最佳实践。</p><h4 id=12-url-query-使用下划线分隔单词>12. URL Query 使用下划线分隔单词<a hidden class=anchor aria-hidden=true href=#12-url-query-使用下划线分隔单词>#</a></h4><p>查询字符串是 URL 的组成部分。URL 规范规定查询字符串的不同参数使用与号（&）分隔，参数名与值使用等号（=）分隔。
当我们在 URL Query 中命名参数名称与值时，建议使用下划线。
如一个使用下划线的查询参数可能如下所示：</p><pre tabindex=0><code>first_name=john&amp;last_name=doe
</code></pre><p>而使用连字符的查询参数则可能如下所示：</p><pre tabindex=0><code>first-name=john&amp;last-name=doe
</code></pre><p>虽然在技术上两者都是有效的，但使用下划线表示被连接的不同单词是一个整体，更符合 REST API 的最佳实践，并且更容易读写和阅读。
当然这不是绝对的，对于一些复杂的情况，下划线和连字符可以混用。</p><pre tabindex=0><code>name_birthdate=john_doe-2023_06_09
</code></pre><p>其中 john_doe 表示一个整体，2023_06_09 表示一个整体，二者通过连字符分隔。</p><h4 id=13-使用-http-状态码>13. 使用 HTTP 状态码<a hidden class=anchor aria-hidden=true href=#13-使用-http-状态码>#</a></h4><pre><code>你应该在对你的 API 请求的响应中始终使用常规的 HTTP 状态代码。这将帮助你的用户知道发生了什么——请求是否成功，或者是否失败，或者其他情况。
下面的表格显示了不同的 HTTP 状态代码范围和它们的含义：
</code></pre><h1 id=http-状态码速查表>HTTP 状态码速查表<a hidden class=anchor aria-hidden=true href=#http-状态码速查表>#</a></h1><table><thead><tr><th style=text-align:left>类别</th><th style=text-align:center>状态码</th><th style=text-align:left>状态描述 (Reason Phrase)</th><th style=text-align:left>含义与应用场景</th></tr></thead><tbody><tr><td style=text-align:left><strong>1xx</strong></td><td style=text-align:center>100</td><td style=text-align:left>Continue</td><td style=text-align:left><strong>继续</strong>：服务器已收到请求头，客户端应继续发送请求体。</td></tr><tr><td style=text-align:left><strong>信息</strong></td><td style=text-align:center>101</td><td style=text-align:left>Switching Protocols</td><td style=text-align:left><strong>切换协议</strong>：升级为 WebSocket 等协议。</td></tr><tr><td style=text-align:left>&mdash;</td><td style=text-align:center>&mdash;</td><td style=text-align:left>&mdash;</td><td style=text-align:left>&mdash;</td></tr><tr><td style=text-align:left><strong>2xx</strong></td><td style=text-align:center>200</td><td style=text-align:left>OK</td><td style=text-align:left><strong>成功</strong>：请求已正常处理。</td></tr><tr><td style=text-align:left><strong>成功</strong></td><td style=text-align:center>201</td><td style=text-align:left>Created</td><td style=text-align:left><strong>已创建</strong>：成功创建了新资源（如 POST 创建用户）。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>204</td><td style=text-align:left>No Content</td><td style=text-align:left><strong>无内容</strong>：处理成功但无需返回数据（如删除资源）。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>206</td><td style=text-align:left>Partial Content</td><td style=text-align:left><strong>部分内容</strong>：范围请求成功（如断点续传、分段下载）。</td></tr><tr><td style=text-align:left>&mdash;</td><td style=text-align:center>&mdash;</td><td style=text-align:left>&mdash;</td><td style=text-align:left>&mdash;</td></tr><tr><td style=text-align:left><strong>3xx</strong></td><td style=text-align:center>301</td><td style=text-align:left>Moved Permanently</td><td style=text-align:left><strong>永久重定向</strong>：资源已永久移动到新 URL。</td></tr><tr><td style=text-align:left><strong>重定向</strong></td><td style=text-align:center>302</td><td style=text-align:left>Found</td><td style=text-align:left><strong>临时重定向</strong>：资源临时移动，SEO 不会更新权重。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>304</td><td style=text-align:left>Not Modified</td><td style=text-align:left><strong>未修改</strong>：使用本地缓存，不返回资源。</td></tr><tr><td style=text-align:left>&mdash;</td><td style=text-align:center>&mdash;</td><td style=text-align:left>&mdash;</td><td style=text-align:left>&mdash;</td></tr><tr><td style=text-align:left><strong>4xx</strong></td><td style=text-align:center>400</td><td style=text-align:left>Bad Request</td><td style=text-align:left><strong>错误请求</strong>：语义有误或参数错误，服务器无法理解。</td></tr><tr><td style=text-align:left><strong>客户端</strong></td><td style=text-align:center>401</td><td style=text-align:left>Unauthorized</td><td style=text-align:left><strong>未授权</strong>：需要进行身份验证。</td></tr><tr><td style=text-align:left><strong>错误</strong></td><td style=text-align:center>403</td><td style=text-align:left>Forbidden</td><td style=text-align:left><strong>禁止</strong>：服务器拒绝执行（通常是权限不够）。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>404</td><td style=text-align:left>Not Found</td><td style=text-align:left><strong>未找到</strong>：服务器上找不到请求的资源。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>405</td><td style=text-align:left>Method Not Allowed</td><td style=text-align:left><strong>方法禁用</strong>：如接口只支持 GET，你用了 POST。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>429</td><td style=text-align:left>Too Many Requests</td><td style=text-align:left><strong>请求过多</strong>：触发了 API 的频率限制。</td></tr><tr><td style=text-align:left>&mdash;</td><td style=text-align:center>&mdash;</td><td style=text-align:left>&mdash;</td><td style=text-align:left>&mdash;</td></tr><tr><td style=text-align:left><strong>5xx</strong></td><td style=text-align:center>500</td><td style=text-align:left>Internal Server Error</td><td style=text-align:left><strong>服务器内部错误</strong>：代码报错、数据库挂了等。</td></tr><tr><td style=text-align:left><strong>服务器</strong></td><td style=text-align:center>502</td><td style=text-align:left>Bad Gateway</td><td style=text-align:left><strong>网关错误</strong>：Nginx 转发到了一个失效的后端服务。</td></tr><tr><td style=text-align:left><strong>错误</strong></td><td style=text-align:center>503</td><td style=text-align:left>Service Unavailable</td><td style=text-align:left><strong>服务不可用</strong>：服务器超载或正在维护。</td></tr><tr><td style=text-align:left></td><td style=text-align:center>504</td><td style=text-align:left>Gateway Timeout</td><td style=text-align:left><strong>网关超时</strong>：后端处理太慢，导致网关等待超时。</td></tr></tbody></table><pre tabindex=0><code>常用:
200 OK: 一切正常。
301 vs 302: 永久重定向（SEO 权重转移） vs 临时重定向。
403 vs 404: 拒绝访问（有资源但没权限） vs 找不到资源。
500: 代码写错了，或者服务器炸了。
502 vs 504: 网关收到错误响应 vs 网关没收到响应（超时）。

简略:
1 (Informational): 正在响应（信息中转）
2 (Success): 已经成功
3 (Redirection): 需要重定向
4 (Client Error): 是客户端的错
5 (Server Error): 是服务器的错
</code></pre><h4 id=14-提供有用的错误消息>14. 提供有用的错误消息<a hidden class=anchor aria-hidden=true href=#14-提供有用的错误消息>#</a></h4><pre><code>除了提供恰当的 HTTP 状态代码外，还应该在 HTTP 响应正文中提供有用且详细的错误描述。
比如GET /mysite.com/posts?category=unknow&amp;page=1&amp;size=10 请求，如果入参有误，应该准确告知调用方。
</code></pre><pre tabindex=0><code>// 400 Bad Request
{
  &#34;code&#34;: 10000,
  &#34;msg&#34;:&#34;Invalid category. Valid values are &#39;biz&#39; or &#39;tech&#39;&#34;
}
</code></pre><h4 id=15-明确版本划分>15. 明确版本划分<a hidden class=anchor aria-hidden=true href=#15-明确版本划分>#</a></h4><pre><code>REST API 应该有不同的版本，因为如果有不兼容和破坏性的更改，版本号将让你能更容易发布 API，且不会破坏用户的应用程序。
划分 API 版本，常见的做法是在 URL Path 中加入版本标识。
</code></pre><pre tabindex=0><code>/v1/employees
/v2/employees
</code></pre><p>许多科技巨头和个人的 REST API 通常是这样做的，例如 Facebook 与 Spotify
当您以这种方式提供 REST API 时，您不需要强迫客户端迁移到新版本，如果他们不想迁移的话。</p><h4 id=16-使用-hateoas>16. 使用 HATEOAS<a hidden class=anchor aria-hidden=true href=#16-使用-hateoas>#</a></h4><pre><code>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在响应中给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。
</code></pre><p>HATEOAS 是 Hypermedia As The Engine Of Application State 的缩写，从字面上理解是 “超媒体即是应用状态引擎” 。其原则就是客户端与服务器的交互完全由超媒体动态提供，客户端无需事先了解如何与数据或服务器交互。相反的，在一些 RPC 服务或 Redis、MySQL 等软件，需要事先了解接口定义或特定的交互语法。</p><p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p><pre tabindex=0><code>{
  ...
  &#34;feeds_url&#34;: &#34;https://api.github.com/feeds&#34;,
  &#34;followers_url&#34;: &#34;https://api.github.com/user/followers&#34;,
  &#34;following_url&#34;: &#34;https://api.github.com/user/following{/target}&#34;,
  &#34;gists_url&#34;: &#34;https://api.github.com/gists{/gist_id}&#34;,
  &#34;hub_url&#34;: &#34;https://api.github.com/hub&#34;,
  ...
}
</code></pre><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><h4 id=17-提供准确的-api-文档>17. 提供准确的 API 文档<a hidden class=anchor aria-hidden=true href=#17-提供准确的-api-文档>#</a></h4><pre><code>当你创建 REST API 时，你需要帮助用户（消费者）正确学习并了解如何使用它。最好的方法是为 API 提供良好的文档。
</code></pre><p>文档应包含：</p><ul><li>API 的相关端点</li><li>端点的示例请求</li><li>在几种编程语言中的实现</li><li>不同错误的消息列表及其状态代码</li></ul><p>你可以用于 API 文档的最常用工具是 Swagger。你也可以使用 Postman 来记录你的 API，这是软件开发中最常见的 API 测试工具。</p><h4 id=18-使用-tls-保障安全>18. 使用 TLS 保障安全<a hidden class=anchor aria-hidden=true href=#18-使用-tls-保障安全>#</a></h4><pre><code>TLS（Transport Layer Security）指的是传输层安全协议。这对 REST API 的安全性至关重要。使用 SSL 可以保护你的 API，使其更不容易受到恶意攻击。
</code></pre><p>TLS 证书不难加载到服务器上，而且大多数情况下在第一年是免费的。即使需要购买，它们也并不昂贵。</p><p>运行在 TLS 上的 REST API 的 URL 与不运行在 TLS 上的 URL 的明显区别是协议 HTTP 中是否包含 s，https://mysite.com/posts 运行在 TLS 上，http://mysite.com/posts 不运行在 TLS 上。</p><p>你还应考虑其他安全措施，比如对请求做身份校验。</p><h4 id=19-使用统一的错误码>19. 使用统一的错误码<a hidden class=anchor aria-hidden=true href=#19-使用统一的错误码>#</a></h4><pre><code>同一个服务的不同 API 或不同系统模块的不同服务的 API 应该使用统一的错误码。
统一的错误码有很多优势。

* 易于维护： 统一的错误码可以使 API 的维护更加简单。当需要调整错误信息或添加新的错误时，只需修改一处错误码定义即可，而无需在整个 API 中查找和修改多处。
* 对调用方友好： 使用统一的错误码可以降低客户端开发的难度。客户端只需关注预定义的错误码，而无需解析和处理不同形式的错误响应。
* 错误诊断和日志记录： 统一的错误码可以帮助开发人员更轻松地诊断 API 中的问题。错误日志中使用统一的错误码可以提供更准确的错误信息，帮助定位和解决问题。
</code></pre><p>在实际应用中，需要根据具体业务场景来选择合适的错误码策略。错误码的设计应该符合 API 的业务逻辑和语义，同时也需要与客户端开发人员进行充分的沟通和协商。
下面是一些常见的错误。</p><table><thead><tr><th style=text-align:left>code</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>10000</td><td style=text-align:left>入参有误</td></tr><tr><td style=text-align:left>10001</td><td style=text-align:left>Token 非法</td></tr><tr><td style=text-align:left>10002</td><td style=text-align:left>请求处理超时</td></tr><tr><td style=text-align:left>10003</td><td style=text-align:left>记录未找到</td></tr><tr><td style=text-align:left>10004</td><td style=text-align:left>DB 写入失败</td></tr><tr><td style=text-align:left>10005</td><td style=text-align:left>DB 更新失败</td></tr><tr><td style=text-align:left>10006</td><td style=text-align:left>DB 查询失败</td></tr><tr><td style=text-align:left>10007</td><td style=text-align:left>DB 删除失败</td></tr><tr><td style=text-align:left>10008</td><td style=text-align:left>JSON 序列化失败</td></tr><tr><td style=text-align:left>10009</td><td style=text-align:left>JSON 反序列化失败</td></tr></tbody></table><p>关于错误码的定义，一般没有固定的规定，不同的系统和应用可能会采用不同的错误码起始值。错误码的起始值通常是根据具体需求和规模来确定的。
比如在大规模的系统中，可能会选择更大的错误码起始值，从 10000、100000 开始，以便在未来可以灵活地添加更多的错误码。</p><h3 id=3一个文章api设计>3.一个文章API设计<a hidden class=anchor aria-hidden=true href=#3一个文章api设计>#</a></h3><p>一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 REST 中这就相当于通用的模板。</p><p>例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种：</p><pre tabindex=0><code>GET 	/articles： 文章列表
GET 	/articles/{id}：文章详情
POST 	/articles： 创建文章
PUT 	/articles/{id}：修改文章
PATCH 	/articles/{id}：修改文章的部分信息
DELETE 	/articles/{id}：删除文章
</code></pre><p>将文章 ID 放在 Path 而不是 Query 中的一个好处是可以表示资源之间的层级关系。
例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于某一篇文章，所以它们的 URL 应该是下面这样的。</p><pre tabindex=0><code>GET 	/comments/{id}： 获取单个评论
GET 	/articles/{id}/comments： 某篇文章的评论列表
POST 	/articles/{id}/comments： 为篇文章创建评论
PUT 	/comments/{id}： 修改评论
PATCH 	/comments/{id}： 修改评论的部分信息
DELETE 	/comments/{id}： 删除评论
</code></pre><p>这里有一点比较特殊，永远使用可以指向资源最短的 URL，也就是说既然 /comments/{id} 可以指向一条评论了，就不要用 /articles/{id}/comments/{id} 特意指出所属文章了。</p><pre tabindex=0><code>GET		/articles/{id}/like：查看文章是否被点赞
PUT		/articles/{id}/like：点赞文章
DELETE 	/articles/{id}/like：取消点赞
</code></pre><p>注意，点赞文章我选择了 PUT 而不是 POST，因为我觉得点赞这种行为应该是幂等的，多次操作的结果应该相同。另外，是否点赞可以直接在获取文章详情时返回，而不用单独写一个接口。</p><h3 id=4rest-api常见问题>4.REST API常见问题<a hidden class=anchor aria-hidden=true href=#4rest-api常见问题>#</a></h3><h4 id=41-批量新增接口如何设计>4.1 批量新增接口如何设计？<a hidden class=anchor aria-hidden=true href=#41-批量新增接口如何设计>#</a></h4><p>使用复数形式的资源名称来表示批量新增多个资源的操作，这与新增单个的接口存在冲突，不建议使用。在资源路径后添加一个表示批量操作的子路径，含义简洁明了，建议使用。</p><pre tabindex=0><code>// 不推荐
POST /resources
// 推荐
POST /resources/batch
</code></pre><h4 id=42-批量查询接口如何设计>4.2 批量查询接口如何设计？<a hidden class=anchor aria-hidden=true href=#42-批量查询接口如何设计>#</a></h4><p>根据 ID 获取单个资源可以使用如下 URL。</p><pre tabindex=0><code>GET /resources/{id}
</code></pre><p>如果需要根据 ID 同时删除多个资源，URL 该如何设计呢？
常见的方式有如下几种。</p><h5 id=第一种path-传参>第一种：Path 传参。<a hidden class=anchor aria-hidden=true href=#第一种path-传参>#</a></h5><p>使用 GET 方法，多个资源 ID 放进 URL Path 中。</p><pre tabindex=0><code>GET /resources/ids/1,2,3...
</code></pre><p>使用 GET 方法时，将多个资源 ID 放到 Path 中传递，并且在路径中加入 ids 标识和单个 ID 接口区分开来。路径中的资源 ID 更具语义化且更具可读性，建议使用。</p><h5 id=第二种query-传参>第二种：Query 传参。<a hidden class=anchor aria-hidden=true href=#第二种query-传参>#</a></h5><p>使用 GET 方法，用多个资源 ID 放进 URL Query 中。</p><pre tabindex=0><code>GET /resources?ids=1,2,3...
</code></pre><p>查询参数可以方便地与其他查询参数一起使用，进行过滤、排序和分页等操作。不过将多个 ID 放到 Query 传递，查询参数不够直观，需要在文档中明确指出如何传递多个 ID。</p><p>注意，由于浏览器和服务器一般对 URL 的长度存在限制（没有统一标准上限，一般为 8192 字节），上面两种方式如果操作的资源过多无法实现。从实际来看，一般批量操作时需要为 ID 数设置一个上限，这样便不会触及 URL 的上限。</p><h5 id=第三种body-传参>第三种：Body 传参。<a hidden class=anchor aria-hidden=true href=#第三种body-传参>#</a></h5><p>使用 GET 方法，用多个资源 ID 放进请求体中。</p><pre tabindex=0><code>GET /resources
Content-Type: application/json

{
  &#34;ids&#34;:[1,2,3]
}
</code></pre><p>虽然 HTTP 规范允许 GET 请求发送请求体，但大多数 Web 服务器和客户端库在处理 GET 请求时会忽略请求体。也就是说，大多数 Web 服务器和客户端库并不期望在 GET 请求中包含请求体，并且可能会忽略或拒绝处理请求体中的数据。
HTTP/1.1 规范（RFC 7231）中指出：</p><blockquote><p>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p></blockquote><p>也就是说 HTTP/1.1 规范虽然允许 GET 请求发送请求体，但是不建议这么做，因为 GET 请求被定义为获取资源的操作，而不是在请求体中发送数据。</p><p>根据 RESTful 设计准则，对于 GET 请求，也不应将请求参数放在请求体中。GET 请求的查询参数应该直接放在 URL 中，而不是放在请求体中。</p><h5 id=第四种post--body-传参>第四种：POST + Body 传参。<a hidden class=anchor aria-hidden=true href=#第四种post--body-传参>#</a></h5><p>使用 POST 方法，将多个 ID 封装在请求体中。请求体可以是 JSON 或其他格式的数据，用于传递多个 ID。</p><pre tabindex=0><code>POST /resources
Content-Type: application/json

{
  &#34;ids&#34;: [1, 2, 3]
}
</code></pre><p>由于 POST 语义上不符合实际的查询动作，所以建议使用 GET 方法。</p><h4 id=3-批量删除接口如何设计>3. 批量删除接口如何设计？<a hidden class=anchor aria-hidden=true href=#3-批量删除接口如何设计>#</a></h4><p>删除单个资源可以在 URL Path 中指定资源 ID。</p><pre tabindex=0><code>DELETE /resources/{id}
</code></pre><p>如果需要根据 ID 同时删除多个资源，URL 该如何设计呢？
常见的方式有如下几种。</p><h5 id=第一种path-传参-1>第一种：Path 传参。<a hidden class=anchor aria-hidden=true href=#第一种path-传参-1>#</a></h5><p>使用 DELETE 方法，用逗号分隔将多个资源 ID 放进 URL Path 中。</p><pre tabindex=0><code>DELETE /resources/ids/1,2,3...
</code></pre><p>将多个 ID 放到 Path 传递，并且在路径中加入 ids 标识和单个 ID 接口区分开来，清晰明了，建议使用。</p><h5 id=第二种query-传参-1>第二种：Query 传参。<a hidden class=anchor aria-hidden=true href=#第二种query-传参-1>#</a></h5><p>使用 DELETE 方法，用多个资源 ID 放进 URL Query 中。</p><pre tabindex=0><code>DELETE /resources?ids=1,2,3...
</code></pre><p>将多个 ID 放到 Query 传递，查询参数不够直观，需要在文档中明确指出如何传递多个 ID。</p><p>注意，由于浏览器和服务器一般对 URL 的长度存在限制（没有统一标准上限，一般为 8192 字节），上面两种方式如果操作的资源过多无法实现。</p><p>实际上批量删除操作本身是一个非常敏感的操作，一般会对批量删除资源的数量做严格限制，所以不会出现太长的 URL。</p><h5 id=第三种body-传参-1>第三种：Body 传参。<a hidden class=anchor aria-hidden=true href=#第三种body-传参-1>#</a></h5><p>使用 DELETE 方法，将需要删除的资源的 ID 放到请求体里面。</p><pre tabindex=0><code>DELETE /resources
{
&#34;ids&#34;:[1,2,3...]
}
</code></pre><p>HTTP 协议标准并没有规定 DELETE 请求不能带 Body，但是 DELETE 请求体在语义上没有意义，一些网关、代理、防火墙在收到 DELETE 请求后，会把请求的 Body 直接剥离掉，所以不建议 DELETE 携带 Body。</p><h5 id=第四种post--body-传参-1>第四种：POST + Body 传参。<a hidden class=anchor aria-hidden=true href=#第四种post--body-传参-1>#</a></h5><p>改用 POST 方法，将需要删除资源的 ID 放到请求体。</p><pre tabindex=0><code>POST /resources
Content-Type: application/json

{
&#34;method&#34;: &#34;delete&#34;,
&#34;ids&#34;: [1, 2, 3]
}
</code></pre><p>使用 POST 语义上与删除动作不符。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.q-song.top/tags/restful/>Restful</a></li></ul><nav class=paginav><a class=next href=https://blog.q-song.top/posts/lock_differ/><span class=title>下一页 »</span><br><span>Go 中的 Lock使用?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.q-song.top/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>