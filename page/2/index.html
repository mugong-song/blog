<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.153.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Q-song | 技术.生活.阅读.思考</title><meta name=description content="个人博客"><meta name=author content="Mumu"><link rel=canonical href=https://blog.q-song.top/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.q-song.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.q-song.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.q-song.top/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.q-song.top/apple-touch-icon.png><link rel=mask-icon href=https://blog.q-song.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.q-song.top/index.xml title=rss><link rel=alternate type=application/json href=https://blog.q-song.top/index.json title=json><link rel=alternate hreflang=zh href=https://blog.q-song.top/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://blog.q-song.top/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Q-song | 技术.生活.阅读.思考"><meta property="og:description" content="个人博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Q-song | 技术.生活.阅读.思考"><meta name=twitter:description content="个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Q-song | 技术.生活.阅读.思考","url":"https://blog.q-song.top/","description":"个人博客","logo":"https://blog.q-song.top/favicon.ico","sameAs":["https://github.com/mugong-song","index.xml","mailto:tomsfamily01@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.q-song.top/ accesskey=h title="Q-song (Alt + H)"><img src=https://blog.q-song.top/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.q-song.top/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://blog.q-song.top/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://blog.q-song.top/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://blog.q-song.top/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://blog.q-song.top/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>垃圾回收机制 Garbage Collection</h2></header><div class=entry-content><p>1.垃圾回收的认识 1.1垃圾回收是什么，有什么作用 GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。 当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请 时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。而 负责垃圾回收的程序组件，即为垃圾回收器。 垃圾回收其实是一个完美的“Simplicity is Complicated”的例子。一方面，程序员受益于 GC，也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。另一 方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。 通常，垃圾回收器的执行过程被划分为两个半独立的组件：
1）赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户 态的代码仅仅只修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上 进行操作。 2）回收器（Collector）：负责执行垃圾回收的代码。
1.2常见的垃圾回收的实现方式有哪些，Go使用的是什么 所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这 两种形式的混合运用。
（1）追踪式 GC 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的 对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。 （2）引用计数式 GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较 多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。 比较常见的 GC 实现方式包括：
1）追踪式，分为多种不同类型，例如： 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内 存上。 2)增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量推进垃圾回收，达到 近似实时、几乎无停顿的效果。 3)增量整理：在增量式的基础上，增加对对象的整理过程。 4)分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于 某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不 长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p></div><footer class=entry-footer><span title='2025-10-12 00:00:00 +0000 UTC'>2025年10月12日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 垃圾回收机制 Garbage Collection" href=https://blog.q-song.top/posts/garbage-collection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>你会使用chan吗?</h2></header><div class=entry-content><p>chan 是 Go 语言并发编程中最核心的概念之一，它是 Channel（通道） 类型的关键字缩写。
Channel 的设计理念源于通信顺序进程（CSP, Communicating Sequential Processes），它提供了一种安全、同步的方式，让不同的 Goroutine（并发执行的“工人”）之间可以进行通信和数据交换。
1.什么是 chan (通道)？ Channel 可以被理解为一个管道或队列，它具有以下核心特性：
类型安全： Channel 只能传输它在创建时指定的特定类型的数据。 例如：chan int 只能传输 int 整数。 同步机制： Channel 默认会阻塞发送和接收操作，直到另一端准备好。 并发安全： Go 运行时保证了对 Channel 的发送和接收操作是线程安全的，无需额外的锁（sync.Mutex）。 2.chan 怎么使用？ 使用 Channel 主要分为三个步骤：创建、发送、接收。
2.1 创建 Channel 使用 make 函数创建 Channel。
//无缓冲通道 (Unbuffered) ch := make(chan Type) //容量为 0。发送和接收操作必须同时准备好，否则先执行的操作会一直阻塞，直到另一个操作发生。用于严格的同步。 ch := make(chan Type, N) //有缓冲通道 (Buffered) //容量为 N。通道可以存储 N个元素。只有当通道满了（发送）或空了（接收）时，操作才会阻塞。用于解耦和提高吞吐量。 dataCh := make(chan string) // 无缓冲，用于同步信号 taskCh := make(chan int, 10) // 有缓冲，容量为 10，用于传输任务 类型 语法 目的 切片 make([]Type, length, capacity) 分配底层数组，设置切片的长度和容量。 映射 make(map[KeyType]ValueType, capacity) 分配和初始化哈希表结构。 通道 make(chan Type, capacity) 创建通道并设置其缓冲大小。 2.2 发送数据 使用箭头操作符 &lt;- 将数据发送到 Channel。
...</p></div><footer class=entry-footer><span title='2025-10-02 00:00:00 +0000 UTC'>2025年10月2日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 你会使用chan吗?" href=https://blog.q-song.top/posts/chan_usage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go sheduler 是什么?</h2></header><div class=entry-content><p>Go sheduler是什么? Go 程序的执行有两个层面：Go Program 和 Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutine 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。
Go scheduler 可以说是 Go 运行时的一个最重要的 部分了。 Runtime 维护所有的 goroutine ，并通过 scheduler 来进行调度。goroutine 和 threads 是独立的， 但是 goroutine 要依赖 threads 才能执行。 Go 程序执行的高效和 scheduler 的调度是分不开的。 实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutine 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面，操作系统并不能感知到 goroutine 的存在。
G、M、P三个基础的结构体来实现 goroutine 的调度： G 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。 M 表示内核线程，包含正在运行的 goroutine 等字段。 P 代表一个虚拟的CPU Processor，它维护一个处于 Runnable 状态的 goroutine 队列，M 需要获得 P 才能运行 G。 当然还有一个核心的结构体：sched，它总揽全局，维持整个调度器的运行。 Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一 个 M 用来开始 G 的运行。随着时间的推移，G和M的创建数量逐渐增多。 在 Go 的早期版本，并没有 P 这个结构体，M 必须从一个全局的队列里获取要运行的 G，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来调度器在 Dmitry Vyukov (Go 语言运行时 runtime 和调度器的核心贡献者之一) ，加 上了 P 结构体。每个 P 维护一个处于 Runnable 状态的 G 的队列，解决了原来的全局锁问题。
...</p></div><footer class=entry-footer><span title='2025-09-07 00:00:00 +0000 UTC'>2025年9月7日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Go sheduler 是什么?" href=https://blog.q-song.top/posts/gmp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>内存对齐（memory alignment）</h2></header><div class=entry-content><p>内存对齐（Memory Alignment）是计算机系统架构和编程中的一个基本概念，它指的是数据在内存中的存储地址必须是某个值的整数倍。这个“某个值”通常是该数据类型的大小或其最大成员的大小（在结构体中）。
通过分析以下具体实例加深内存对齐理解。
type itab struct { inter *interfacetype // 接口类型信息 _type *_type // 实现接口的具体类型信息 hash uint32 // 类型 hash 值 _ [4]byte fun [1]uintptr // 实现接口方法的函数地址 } 一、Go 的结构体内存布局规则 Go 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。
规则大致是： 每个字段的起始地址必须是该字段类型的对齐倍数。 比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。 整个结构体的大小必须是其内部最大对齐单位的整数倍。 编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。
二、itab 的字段分析（以 64位架构为例） 我们来计算每个字段的内存偏移：
字段 类型 大小 (Size) 自身对齐值 (Align) 偏移量 (Offset)单位:字节 备注 inter *interfacetype 8 字节 8 字节 0 → 8 8 字节对齐 _type *_type 8 字节 8 字节 8→16 8 是 8 的倍数，已对齐 hash uint32 4 字节 4 字节 16→20 16 是 4 的倍数，已对齐 _ [4]byte 4 字节 1 字节 20→24 4 字节的填充 (Padding) fun [1]uintptr 8 字节 8 字节 24→32 8 字节对齐 24 是 8 的倍数 总大小32 字节，结构体最大对齐是 8 字节，总大小 32 是 8 的倍数。
...</p></div><footer class=entry-footer><span title='2025-09-05 00:00:00 +0000 UTC'>2025年9月5日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 内存对齐（memory alignment）" href=https://blog.q-song.top/posts/memory_alignment/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>主键和唯一键？区别是什么？</h2></header><div class=entry-content><p>主键（Primary Key）是唯一标识每行的非空字段，每表只能有一个； 唯一键（Unique Key）是保证字段值唯一，但允许为NULL，每表可有多个。
主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。
唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。
主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。
用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。
约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。
索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。
简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结
主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。</p></div><footer class=entry-footer><span title='2025-09-04 00:00:00 +0000 UTC'>2025年9月4日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 主键和唯一键？区别是什么？" href=https://blog.q-song.top/posts/sql_key/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL_Index 索引</h2></header><div class=entry-content><p>在 Go 后端开发中，我们通常使用 MySQL 或 PostgreSQL 等关系型数据库，索引设计的好坏直接决定了服务接口的响应速度。
1.索引设计 1.1 选择合适的列作为索引： 选择性高（High Selectivity）： 索引列的不重复值越多越好。例如，用户 ID（唯一）比性别（只有两三种值）更适合作为索引。 场景： 在设计用户服务时，user_id、email 等是理想的索引列。 常用作查询条件（Where）： 经常出现在 WHERE 子句中的列，或者用于连接（JOIN）的列。 排序/分组（Order By/Group By）： 经常用于排序或分组的列。 1.2 考虑联合索引（Composite Index）： 最左前缀原则 (Leftmost Prefix Principle)： 这是联合索引设计的核心。如果创建了 (A, B, C) 的联合索引，它可以用于查询 WHERE A = ?、WHERE A = ? AND B = ?、WHERE A = ? AND B = ? AND C = ?，但不能单独用于 WHERE B = ? 或 WHERE C = ?。 场景： 在设计订单查询接口时，如果经常查询 WHERE user_id = ? AND order_status = ?，应建立 (user_id, order_status) 的联合索引。 1.3 覆盖索引 (Covering Index)： 如果查询的所有字段都包含在索引中，那么数据库不需要回表（查找主键对应的数据行），直接从索引中返回数据即可。这能大幅提升性能。 场景： 当你需要查询某个用户的订单状态和创建时间，只创建 (user_id, status, create_time) 的联合索引。查询语句为 SELECT status, create_time FROM orders WHERE user_id = ?，数据库直接通过索引就能拿到结果。 1.4 索引数量的平衡： 索引不是越多越好。每个索引都会占用磁盘空间，并且在进行 INSERT, UPDATE, DELETE 操作时，数据库需要维护索引，造成写操作性能下降。 场景： 在设计高写入量的日志表或消息表时，应尽量少建索引，只保留用于最核心查询的索引。 2.高效命中策略 使用 Explain ： 在 Go 后端进行复杂查询优化时，一定要在测试环境使用 EXPLAIN 命令分析 SQL 语句，确保 type 列不是 ALL（全表扫描），key 列使用了正确的索引。
...</p></div><footer class=entry-footer><span title='2025-09-03 00:00:00 +0000 UTC'>2025年9月3日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to SQL_Index 索引" href=https://blog.q-song.top/posts/sql_index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>slice 和 数组</h2></header><div class=entry-content><p>Go 语言里 slice 和 map 是非常有用的两个内置数据结构， 线上的工程代码几乎不可能绕开它们。
1.数组与切片 因为切片（slice）比数组更好用，也更安全，Go 推荐使用 slice 而不是数组。本节内容比较 了 slice 和数组的区别，也研究了 slice 的一些特有的性质。
1.1数组和切片有何异同 Go 语言中的切片（slice）结构的本质是对数组的封装，它描述一个数组的片段。无论是数组 还是切片，都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更改。在 Go 语言中，数组是不常见的，因为其长度 是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。而切片则非常灵 活，它可以动态地扩容，且切片的类型和长度无关。
func main() { arr1 := [1]int{1} arr2 := [2]int{1, 2} if arr1 == arr2 { fmt.Println("equal type") } } 尝试运行，报编译错误：
./test.go:16:10: invalid operation: arr1 == arr2 (mismatched types [1]int and [2]int) 因为两个数组的长度不同，根本就不是同一类型，因此不能进行比较。 数组是一片连续的内存，切片实际上是一个结构体，包含三个字段：长度、容量、底层数组。
// src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 注意，底层数组可以被多个切片同时指向，因此对一个切 片的元素进行操作有可能会影响到其他切片。
...</p></div><footer class=entry-footer><span title='2025-09-02 00:00:00 +0000 UTC'>2025年9月2日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to slice 和 数组" href=https://blog.q-song.top/posts/slice_01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我的第一篇博客</h2></header><div class=entry-content><p>今天开始记录我在 Go 高并发项目中的一些心得体会。</p></div><footer class=entry-footer><span title='2025-09-02 00:00:00 +0000 UTC'>2025年9月2日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 我的第一篇博客" href=https://blog.q-song.top/posts/fist-blog/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>First Encounter with Hugo</h2></header><div class=entry-content><p>🚀 什么是 Hugo？ Hugo 是一个基于 Go 语言编写的 静态网站生成器。
它的最大特点是——速度极快、部署方便、几乎零依赖。
使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。
🛠️ 安装 Hugo 在 macOS 上：
brew install hugo</p></div><footer class=entry-footer><span title='2025-09-01 15:30:00 +0800 +0800'>2025年9月1日</span>&nbsp;·&nbsp;<span>Beeta</span></footer><a class=entry-link aria-label="post link to First Encounter with Hugo" href=https://blog.q-song.top/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我的项目</h2></header><div class=entry-content><p>电商购物平台 & 管理后台（Go + Iris + MySQL + Redis + RabbitMQ + Nginx）
前后端一体化 Web 项目，从前端 UI、后端接口、数据库设计到上线部署。 这是我从零开始独立完成的完整的前后端一体化Web项目，从前端UI、后端接口、数据库设计到上线部署，都是自己亲手实现。 项目的目标是构建一个完整的电商流程：商品浏览、分类展示、购物车、订单流程，以及后台的商品管理、订单管理、用户管理等。 用户端界面展示 “宇宙购物”（SPACE SHOPPING）的电商平台，整体风格现代、简洁、实用。
瀑布流布局 & 搜索栏
商品分类导航(多级导航栏)
商品详情(加入购物车、立即抢购)
高性能排行榜单
用户下单(确认和生成订单)
页面的 UI 风格参考了大型电商平台（如淘宝、京东）的布局结构，整体结构清晰，视觉优雅。
管理后台系统 后台系统提供api管理全站信息，是自己设计的简洁的CMS管理平台。
订单管理 商品管理 支持新增、编辑、删除商品，上传图片，设置库存、分类等。
商品分类管理 查看商品分类明细和支持新增、编辑、删除等操作
用户管理 查看用户列表、状态，支持冻结/启用。
管理员管理 查看管理员列表、状态，支持冻结/启用。
技术栈 前端： HTML + CSS + JS 部分页面使用 Vue 简化动态逻辑 管理后台基于 Admin 模板自定义开发 后端： Go（Golang） Iris Web 框架 MySQL（核心数据） + Redis（缓存 & session） JWT 登录认证 RabbitMQ（异步消息） Nginx（反向代理） 部署： Ubuntu Server systemd 服务托管（自动重启、日志收集） Nginx 反代 / 静态资源服务 二进制打包发布，软链接切换版本（current → eshop_v2） 项目亮点 支持高并发的基础架构搭建 项目内集成了： Redis 缓存 RabbitMQ 消息队列 Nginx 负载均衡预留接口 为将来扩展秒杀、异步通知等功能做了铺垫。 碎碎念 哈哈当然啦，在开发的整个过程还是有许多收获的。 例如加深对Go语言的熟悉程度、各种中间件和相互之间的如何应用、如何构建一个高可靠和高可用的系统、 在高并发条件下如何容错、如何解决数据可能丢失和学会排查系统错误、端口冲突、模板路径问题等等。 也许在不久还会有更多出色的应用，敬请期待吧~</p></div><footer class=entry-footer><span title='2024-12-31 00:00:00 +0000 UTC'>2024年12月31日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 我的项目" href=https://blog.q-song.top/posts/my_project01/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.q-song.top/>«&nbsp;上一页&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://blog.q-song.top/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>